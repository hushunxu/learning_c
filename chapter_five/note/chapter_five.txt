第5章 指针与数组

指针：一种保存变量地址的变量。

声明：
	type *var-name  
	
	*声明指针
	
	var-name 变量名
	
	int    *ip;    /* 一个整型的指针 */
    double *dp;    /* 一个 double 型的指针 */
    float  *fp;    /* 一个浮点型的指针 */      
    char   *ch;    /* 一个字符型的指针 */


5.1 指针与地址

一个字节存放一个char类型的数据
两个相邻字节存储单元可以存储一个short（短整型）类型的数据
4个相邻字节存储单元可存储一个long（长整型）类型的数据

一元运算符&，可读取一个对象的地址，如
p = &c;
将c的地址赋值给变量p，我们称p为指向c的指针。
地址运算符&只能用于内存中的对象，及变量与数组元素。不能用作表达式、常量或register类型的变量。

一元运算符*，是间接寻址或间接引用运算符。当它用于指针时，将访问指针所指向的对象。

指针声明：
int *ip;

一元运算符*和&的优先级比算术运算符的优先级高。

5.2指针与函数参数

C语言以传值的方式将参数值传递给被调用函数，因此，被调用函数不能直接修改主调函数中变量的值。
指针参数使得被调用函数能够访问和修改主调函数中的对象的值。

getch()
直接等待获取从键盘输入的字符，不回显在屏幕，不用以回车键结尾，每输完一个按键，程序读取按键对应的ASCII码并返回。

getchar()
函数开始后，去stdio缓冲区看是否有字符，有则获取一个字符返回给程序，函数结束。
如果stdio缓冲区为空，则等待从键盘输入数据，同时每输入一个字符都会显示在屏幕，只有当回车键'\n'，才将按回车键之前包括回车键的数据缓存到stdio缓存区里，然后从stdio缓冲区获取第一个字符，并返回给程序。同时，缓冲区的字符指针往下移动一位，函数结束。

ungetch()
把一个字符回退到键盘缓冲区内

stido缓冲区：
从内存中读数据比从文件中读数据快得多，对文件的读写需要用到open、read、white等底层函数，而用户进程每调用一次，系统函数都要从用户态切换到系统态，等执行完再返回用户态，这种切换需要一定的时间成本，因此有了缓冲区。

比如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以减少磁盘的读写次数，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大提高计算机的运行速度。

缓冲区又称为缓存，它是内存空间的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。

缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区。

缓冲区就是一块内存区，它用在输入输出设备和CPU之间，用来缓存数据。它使得低速的输入输出设备和高速的CPU能够协调工作，避免低速的输入输出设备占用CPU，解放出CPU，使其能够高效率工作。

5.3 指针与数组

pa = &a[0];
可以将指针pa指向数组a的第0个元素，也就是说，pa的值为数组元素a[0]的地址。
如果指针pa指向a[0],那么*(pa+1)引用的是数组元素a[1]的内容，pa+i是数组元素a[i]的地址，*(p+i)引用的是数组元素a[i]的内容。

指针+1，意味着pa+1指向pa所指向的对象的下一个对象；相应地，pa+i所指向的对象之后第i个对象。

数组类型的变量或表达式的值是该数组第0个元素的地址，执行pa = &a[0];pa和a具有相同的值。

因为数组名代表的就是该数组最开始第一个元素的地址，因此pa = &a[0];也可以写成 pa = a;

对数组元素a[i]的引用也可以写成*(a+i)这种形式。

&a[i]和a+i的含义也是相同的，a+i是a之后第i个元素的地址。相应地，如果pa是一个指针，在表达式也可以在它的后面加下标。
pa[i]与*(pa+i)是等价的。简而言之，有个通过数组和下标实现的表达式可以等价地通过指针和偏移量实现。

注意：数组名和指针之间有一个不同之处：指针是一个变量，因此pa = a和pa++都是合法的，但数组名不是变量。因此类似a = pa和a++形式的语句是非法的。

把数组名传递给一个函数时，实际上传递的是该数组第一个元素的地址。

函数定义中，形式参数char s[]和char *s是等价的

5.4地址算术运算

如果p是一个指向数组中某个元素的指针，那么p++将对p进行自增运算并指向下一个元素；而p += i将对p进行加i的增量运算，使其指向指针p当前所指元素之后第i个元素。

指针初始化，对指针有意义的初始化只能是0或表示地址的表达式，对后者来说，表达式所代表的地址必须是此前已定义的具有适当类型的数据的类型。

指针与整数之间不能相互转换，但0是唯一的例外：常量0可以赋值给指针，指针也可以和常量0进行比较。

如果指针p和q指向同一个数组的成员，那么它们之间可以进行类似==、!=、<、>、>=的关系比较运算。
但是，指向不同数组的元素指针之间的算术或比较运算符没有意义。（有一个特例：指针的算术运算符可使用数组最后一个元素的下一个元素的地址）

指针可以和整数进行相加或相减运算，如p + n;表示指针p当前所指向的独享之后第n个对象地址。

指针算术具有一致性：如果处理的数据类型是比浮点类型，并且p是一个指向浮点类型的指针，那么执行p++后，p将指向下一个浮点数的地址。


有效的指针运算包括：
相同类型指针之间的赋值运算；
指针同整型之间的加法或减法运算；
指向相同数组中元素的两个指针间的减法或比较运算；
将指针赋值为0或指针与0之间的比较运算。
其他所有形式的指针运算都是非法的。